In C, strings are sequences of values typically representing characters. They are implemented as arrays of characters, and libraries that take strings as input expect an array of characters. Passing a string to a function in C does not require copying all the memory, but instead passes the pointer (the address). The null terminator, an additional character with the value of 0, is appended to the end of a string to denote the end. The null terminator can also be represented by the character literal '\0'. It is the only character that evaluates to false in C, making code shorter when checking for null terminators. Allocating memory for strings requires more space than the characters in the string due to the null terminator. For example, the string "apple" with 5 characters must be stored in an array with at least 6 characters. Failure to allocate enough memory can lead to array out of bounds errors. It is recommended to always add 1 to the allocation for strings.
The article discusses string functions in the C standard library, which can be included in a program using the <string.h> header file. These functions deal with character pointers since strings are arrays and arrays are pointers. One of the most simple string functions is strlen, which takes the address of the first character of a string as an argument and returns the number of characters before the first null terminator. The article includes an example of how strlen can be implemented.
In this note, the author discusses the common mistake made by beginning programmers that can cause programs to be unnecessarily slow when processing strings. They provide two examples of code, one slower than the other, to demonstrate this concept. 

The first example code creates a string with a large number of 'a' and 'b' characters. It then counts the number of 'a' characters in the string using the strlen function, which iterates through each character in the string until it reaches the null terminator. This repetitive string length computation slows down the program unnecessarily.

The second example code is a faster version of the first program. It computes the string length once and stores it in a variable called "len". It then uses this stored value in the for loop to count the number of 'a' characters in the string. By avoiding the recomputation of the string length, this version of the program achieves better performance.

The author also mentions a third version that they claim is arguably faster but does not provide details about it.
The code provided is an example program in C that demonstrates the use of the #define directive, the sizeof operator, and the strcpy function.

In the first part of the code, the size of an array is defined using the #define directive. The main function then initializes a character array called "str" with a length of "size + 1" and fills it with random 'a' and 'b' characters.

The program then counts the number of 'a' characters in the string using a for loop and an if statement. The count is stored in the variable "count".

After that, the strcpy function is introduced. It is explained that this function is used to copy the contents of one string into another. The function takes two string pointers as input and returns a pointer to the newly written string.

An example of how to use the strcpy function is provided in the main function. The word "apple" is stored in the "str" array using the strcpy function.

The program then exits with a return value of 0.

The author's note mentions that the return value of the strcpy function is not commonly used and warns about potential issues with overlapping strings and array out of bounds errors.
This text describes the implementation of the strcpy and strcat functions in C programming. The strcpy function copies the contents of the source string to the destination string, while the strcat function appends the contents of the second string to the end of the first string. The text provides an example implementation of both functions and warns about potential issues such as overlapping strings and array out of bounds errors.
On the next page, there is an example of how the strcat function could be implemented. It finds the end of the destination string, copies all the source to the end of the destination, and terminates the resulting string. The function returns the location of the destination string.

Also, the strcmp function is discussed, which is used for finding the lexicographical ordering between two strings. The value returned from strcmp indicates whether the two strings are identical, or if the first differing character in the strings is greater for the first or second argument. The note advises not to check if the return value is exactly 1, 0, or -1, as it could be any positive or negative value.

The limitations and applications of strcmp are mentioned, including its inability to directly check if a string is a prefix of another string. Examples of using strcmp are provided on the next page.
The code provided includes a possible implementation of the strcmp function and an explanation of how the strncmp function works. The strcmp function is used to compare two strings and returns a negative value if the first string is less than the second, a positive value if the first string is greater than the second, and 0 if the strings are equal. The strncmp function is similar to strcmp, but only compares a limited number of characters.
This code snippet demonstrates the use of the strncmp function to compare strings. It shows different scenarios and their corresponding return values. The code also introduces the strdup function, which dynamically creates a copy of a string. It provides an example of how to use strdup and emphasizes the importance of freeing the memory allocated for the copied string. It suggests checking for a null pointer when using strdup.
The article explains the functions strstr and strcasecmp, as well as provides information on reading strings using scanf. strstr is a function that checks if one string (the needle) is contained within another string (the haystack). If the needle is found, the function returns the start of its location in the haystack; otherwise, it returns null. The strstr function is demonstrated with an example code snippet. strcasecmp is another useful function for comparing strings, treating words with only case differences as equal. If there are other differences between the strings, a standard lexicographical comparison is used. Lastly, the article introduces the scanf function as a method for reading strings, using the "%s" format specifier to read in a string delimited by whitespace.
This code is a C program that declares arrays to hold input, reads in two words ("apple" and "pie"), creates a new string combining the two words, and prints the result. It uses the functions strcpy and strcat to manipulate strings. The code also mentions the use of gets function, but it is deprecated and unreliable, so it suggests using fgets instead.
The provided code demonstrates the use of the fgets function in C to read a line of input. The fgets function reads the contents from a specified file pointer, with the last character becoming the null terminator. It is important to note that fgets also includes the newline character in the string, so the string should be made one character longer than necessary. The example code creates a character array called "line" with a length of 5 for "apple", 1 for the space, 3 for "pie", 1 for the newline, and 1 for the null terminator. It then uses fgets to read in a line from the standard input and prints the line that was read. The author's note advises using a larger value (`max_line_size + 2`) when creating a character array to hold the information read in using fgets, and not using `sizeof(str)` to determine the size of the string.
